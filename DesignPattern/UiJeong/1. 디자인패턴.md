[원본](https://velog.io/@juijeong8324/Design-Pattern-1)

## What is Design Pattern?
- 프로그램을 _**설계할 때 발생했던 문제점들**_을 **_객체 간의 상호 관계_** 등을 이용하여 해결할 수 있도록 _**하나의 '규약' 형태**_로 만들어 놓은 것 
- 일종의 설계 기법이며, 설계 방법
- **목적**   
: SW 재사용성, 호환성, 유지 보수성을 보장. 
- **특징**   
: 특정 구현이 아닌 **_아이디어_**          
: 추후 **_재사용, 호환, 유지 보수시 발생하는 문제 해결을 예방_**하기 위해 패턴을 만들어 둔 것  

<br>

> **✅ 디자인 패턴은 클래스 라이브러리가 아니다.** 
- **클래스 라이브러리**(특정한 기능을 묘듈화) : **부품**이 되는 프로그램
- **디자인 패턴** : **부품이 어떻게 조립**되어 있고, 각각의 **부품이 어떻게 관련**해서 큰 기능을 발휘하는지를 표현 
- 즉, _**어떤 종류의 클래스나 인터페이스가 서로 어떤 관계**_에 있는지 가 중요  

> **✅ 클래스 라이브러리 안에서 디자인 패턴이 사용되고 있다.**
- Java의 표준 클래스 라이브러리 안에는 디자인 패턴이 많이 활용 
- java.util.Iterator : 여러 개를 나열해 갈 때 사용하는 인터페이스 → **_Iterator 패턴_** 
- java.util.Observer : 오브젝트의 상태변화를 관찰하는 인터페이스 → **_Observer 패턴_**
- java.util.Calendar 클래스의 getInstance 메소드, java.security.SecureRandom 클래스의 getInstance 메소드, java.text.NumberFormat 클래스의 getInstance 메소드 → **_Facotry Method 패턴_**
- java.awt.Component, java.awt.Container 클래스 → **_Composite 패턴_**

> **✅ 프로그램을 완성품으로 보지 않는다.**
- 목표 중 하나는 SW 재상용성!! 즉, 프로그램을 어떻게 "부품"으로써 재사용할 수 있는지 생각하는 것 
- **_어떤 기능이 확장될 가능성이 있는가?_**
- **_확장기능을 수행할 때 수정이 필요한 클래스는 무엇인가?_**
- **_수정이 불필요한 클래스는 무엇인가?_**

<br>
<br>

## SOLID(객체지향 설계 원칙)
1. **Single Responsibility** Principle (단일 책임 원칙)
하나의 클래스는 하나의 역할만 해야 함
즉, 클래스는 그 **책임을 완전히 캡슐화**해야 함

2. **Open - Close** Principle (개방-폐쇄 원칙)
**확장(상속)에는 열려**있고, **수정에는 닫혀** 있어야 함
기존의 코드를 변경하지 않으면서(Closed), 기능을 추가할 수 있도록(Open) 설계가 되어야 한다는 원칙
EX) _Override_

3. **Liskov Substitution** Principle (리스코프 치환 원칙)
자식이 부모의 자리에 항상 교체될 수 있어야 함.
즉 **부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동**해야 한다
자식클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야 LSP를 만족한다

4. **Interface Segregation** Principle
인터페이스가 잘 분리되어서, **클래스가 꼭 필요한 인터페이스만 구현**하도록 해야함
하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다

5. **Dependency Inversion** Principle
상위 모듈이 하위 모듈에 의존하면 안됨. **둘 다 추상화에 의존**하며, **추상화는 세부 사항에 의존하면 안됨.**
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 **변화하기 어려운 것, 거의 변화가 없는 것에 의존**하라는 것 
한마디로 **구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺으라**는 것이다

<br>
<br>

## GoF 디자인 패턴 종류 
![](https://velog.velcdn.com/images/juijeong8324/post/51af4a3d-db1d-4813-8657-e3d15b21e5fc/image.png)

### 생성 패턴 (Creational) : 객체의 생성 방식 결정
- _**객체의 인스턴스 과정을 추상화**_하는 방법
- 객체의 생성과 참조 과정을 캡슐화하여 _**객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록**_ 하여 프로그램에 유연성을 더해준다. 
- **생성 클래스 패턴** : 객체를 생성하는 일부를 서브클래스가 담당 
  **생성 객체 패턴** : 객체 생성을 다른 객체에게 위임
> DBConnection을 관리하는 Instance를 하나만 만들 수 있도록 제한하여, 불필요한 연결을 막음.

<br>

### 구조 패턴 (Structural) : 객체간의 관계를 조직
- 구조 패턴은 _**클래스나 객체들을 조합해 더 큰 구조로**_ 만들 수 있게 해주는 패턴이다. 
- **구조 클래스 패턴** : 상속을 통해 클래스나 인터페이스를 합성
  **구조 객체 패턴** : 객체를 합성하는 방법을 정의
> 2개의 인터페이스가 서로 호환이 되지 않을 때, 둘을 연결해주기 위해서 새로운 클래스를 만들어서 연결시킬 수 있도록 함.

<br>

### 행위 패턴 (Behavioral): 객체의 행위를 조직, 관리, 연합
- 행위 패턴은 _**클래스나 객체들이 서로 상호작용하는 방법**_이나 _**어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지를 정의**_하는 패턴이다. 
- 즉, _**객체나 클래스의 교류 방법에 대해 정의**_하는 것이다. 행위 패턴은 하나의 객체로 수행할 수 없는 작업을 _**여러 객체로 분배하면서 그들 간의 결합도를 최소화**_ 할 수 있도록 도와준다. 
- **행위 클래스 패턴** : 상속을 통해 알고리즘과 제어 흐름을 기술
  **행위 객체 해턴** : 하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술
> 하위 클래스에서 구현해야 하는 함수 및 알고리즘들을 미리 선언하여, 상속시 이를 필수로 구현하도록 함.
