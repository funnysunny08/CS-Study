# 4.1 데이터베이스 기본 

데이터베이스는 **일정한 규칙, 혹은 규약을 통해 구조화 되어 저장되는 데이터의 모음**이다. 해당 데이터베이스를 제어, 관리하는 통합 시스템을 **DBMS** (DataBase Management System) 라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 **쿼리 언어**를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다. 또한, 데이터베이스는 **실시간 접근과 동시 공유가 가능**하다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/00953675-c323-4d06-a7da-76552f89a412"/> 

위와 같은 구조를 기반으로 데이터를 주고 받는다. 예를 들어 MySQL이라는 DBMS가 있고, Node.js나 php 같은 응용 프로그램에서 데이터베이스 안에 있는 데이터를 꺼내서 해당 데이터 관련 로직을 수행할 수 있다. 

# 4.1.1 엔터티 

엔터티는 사람, 장소, 물건, 사건, 개념 등 **여러 개의 속성을 지닌 명사**를 의미한다. 예를 들어 회원이라는 엔터티는 이름, 아이디, 주소, 전화번호의 속성을 갖는다.

물론 이보다 더 많은 속성이 있지만 **서비스의 요구사항에 맞춰 속성이 정해진다.** 서비스의 요구사항과 무관한 속성은 엔터티의 속성으로 고려하지 않는다. 

## 약한 엔터티와 강한 엔터티 

엔터티는 약한 엔터티와 강한 엔터티로 나뉜다. 예를 들어 **A가 혼자서는 존재하지 못하고 B의 존재 여부에 종속적**이라면 **A는 약한 엔터티이고 B는 강한 엔터티**가 된다. 

예를 들어 방은 건물 안에만 존재하기 때문에 방은 약한 엔터티, 건물은 강한 엔터티라고 할 수 있다. 

# 4.1.2 릴레이션 

릴레이션은 **데이터베이스에서 정보를 구분하여 저장하는 기본 단위**이다. 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다.

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/672e320b-5605-4383-8056-4e1cdc3e4eeb"/>

위의 그림처럼 회원이라는 엔터티는 데이터베이스에서 관리될 때 릴레이션으로 표현된다. 릴레이션은 관계형 데이터베이스에서는 '테이블', NoSQL 데이터베이스에서는 '컬렉션'이라고 불린다. 

## 테이블과 컬렉션 

데이터베이스의 종류는 크게 관계형 데이터베이스와 NoSQL 데이터베이스로 나눌 수 있다. 대표적인 관계형 DB인 MySQL, 대표적인 NoSQL DB인 MongoDB를 예로 들면, MySQL 구조는 `레코드 - 테이블 - 데이터베이스`로 이루어져 있고 MongoDB는 `도큐먼트 - 컬렉션 - 데이터베이스`로 이루어져 있다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/86872ac5-7e49-4485-b6e3-b166e19cc210"/>

위의 그림처럼 레코드가 쌓여서 테이블이 되고 테이블이 쌓여서 데이터베이스가 된다. 

# 4.1.3 속성 

속성(attribute)는 **릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보**이다. 예를 들어 '차'라는 엔터티의 속성을 뽑아보자. 차량 번호, 색상, 차종 등이 있을 수 있다. 이 중에서 서비스의 요구사항을 기반으로 관리할 필요가 있는 속성들만 엔터티의 속성이 된다. 

# 4.1.4 도메인 

도메인이란 **릴레이션에 포함된 각 속성들이 가질 수 있는 값의 집합**을 말한다. 예를 들어 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여} 라는 집합이 된다. 

<img width="450" src="https://github.com/leeeha/CS-Study/assets/68090939/621637e4-d1ef-4c3e-a553-3b0544fc7b82"/>

위의 그림처럼 회원이라는 릴레이션에 이름, 아이디, 주소, 전화번호, 성별이라는 속성이 있고, 성별은 {남, 여} 라는 도메인을 갖는다. 

# 4.1.5 필드와 레코드 

위에서 설명한 것들을 기반으로 데이터베이스에서 필드와 레코드로 구성된 테이블을 만들 수 있다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/b95e2438-ee1b-41c8-8e0c-353f39a0680a"/>

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/45865a91-fb58-40b9-8ae8-d13133728cb8"/> 

- 회원이라는 **엔터티**는 member라는 **테이블**로 표현된다. 
- 이름, 아이디, 주소, 전화번호 같이 열 단위의 데이터는 **속성, 필드**라고 부른다.
- 테이블에 쌓이는 행 단위의 데이터는 **레코드, 튜플**이라고 부른다. 

## 필드 타입 

이름, 아이디, 주소, 전화번호 같은 속성을 데이터베이스에 넣어 테이블로 만들려면 각 속성에 맞는 타입을 정의해야 한다. 예를 들어 이름은 문자열이고 전화번호는 숫자일 것이다. 이런 타입은 DBMS마다 다르며 앞으로는 MySQL을 기준으로 설명한다. 

### 숫자 타입 

숫자 타입으로는 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있다. 

signed 타입은 가장 왼쪽 bit인 MSB (Most Significant Bit)가 + 또는 - 부호를 나타내는데 사용된다. 그리고 나머지 bit가 숫자 표현에 사용된다.  

|타입|바이트|signed 범위|unsigned 범위|
|---|---|---|---|
|TINYINT|1|-2^7 ~ 2^7-1 (-128 ~ 127)|0 ~ 2^8-1 (255)|
|SMALLINT|2|-2^15 ~ 2^15-1 (-32,768 ~ 32,767)|0 ~ 2^16-1 (65,535)|
|MEDIUMINT|3|-8,388,608 ~ 8,388,607|0 ~ 16,777,215|
|INT|4|-2,147,483,648 ~ 2,147,483,647|0 ~ 4,294,967,296|
|BIGINT|8|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|0 ~ 18,446,744,073,709,551,616|

### 날짜 타입 

날짜 타입으로는 DATE, DATETIME, TIMESTAMP 등이 있다. 

|타입|설명|
|---|---|
|DATE|- 날짜 부분은 있지만 시간 부분은 없는 값에 사용 <br> - 지원되는 범위는 1000-01-01 ~ 9999-12-31 <br> - 3 바이트의 용량|
|DATETIME|- 날짜 및 시간 부분을 모두 포함하는 값에 사용 <br>- 지원되는 범위는 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 <br>- 8 바이트의 용량|
|TIMESTAMP|- 날짜 및 시간 부분을 모두 포함하는 값에 사용 <br>- 지원되는 범위는 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 <br>-4 바이트의 용량|

### 문자 타입 

문자 타입으로는 CHAR, VARCHAR, TEXT, BLOB, ENUM, SET이 있다. 

**CHAR, VARCHAR**

CHAR 또는 VARCHAR 모두 괄호 안에 몇자까지 입력할지 정한다. 

CHAR는 고정 길이 문자열이며 길이는 0~255 사이의 값을 가진다. 레코드를 저장할 때 무조건 선언한 길이 값으로 '고정'해서 저장된다. 예를 들어, CHAR(100)으로 선언하면 10글자를 저장해도 100바이트로 저장된다. 

VARCHAR는 가변 길이 문자열이며 길이는 0~65,535 사이의 값을 가진다. 입력된 데이터 크기에 따라 저장되는 용량도 달라진다. 예를 들어, 10글자의 이메일을 저장하면 VARCHAR(100)으로 선언했어도 `10글자에 해당하는 바이트 + 길이 기록용 1바이트` 크기로 저장된다. 

따라서, CHAR는 유동적이지 않은 길이를 가진 데이터에, VARCHAR는 유동적인 길이를 가진 데이터에 사용하는 게 효율적이다. 

**TEXT, BLOB**

두 개의 타입 모두 큰 데이터를 저장할 때 사용한다. 

TEXT는 게시물의 본문 내용과 같이 크기가 큰 문자열 데이터를 저장하는 데 사용된다. 

BLOB (Binary Large Object, 블랍) 는 이미지, 동영상 등 크기가 큰 데이터 저장에 사용된다. 그러나, 보통은 아마존의 이미지 호스팅 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장하는 경우가 많다. 

**ENUM, SET**

두 타입 모두 문자열을 열거한 타입이다. 

ENUM은 ENUM('x-small', 'small', 'medium', 'large', 'x-large') 형태로 쓰이며, 이 중에서 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다. 

ENUM을 이용하면 'small' 같은 하나의 항목이 0이나 1로 매핑되어 메모리를 적게 사용할 수 있다는 장점이 있다. 그리고 최대 65,535개의 항목을 넣을 수 있다. 

SET은 ENUM과 비슷하지만, 다중 선택이 가능하고 비트 단위의 연산을 수행할 수 있으며 최대 64개의 항목을 넣을 수 있다. 

참고로 ENUM이나 SET을 쓰면 공간적으로 이점을 볼 수 있지만, 어플리케이션의 수정에 따라 데이터베이스의 ENUM 또는 SET에서 정의한 목록도 수정해야 한다는 단점이 있다. 

# 4.1.6 관계 

데이터베이스에서 테이블은 하나만 있지 않다. 여러 개의 테이블이 있으며, 이를 사이의 관계를 정의할 수 있다. 그리고 이런 관계는 아래와 같이 관계 화살표로 표현할 수 있다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/b23a9ef4-7e61-4c91-a24b-d324626c51f0"/>

## 일대일 관계 

유저 한명당 가질 수 있는 이메일이 하나라고 가정하면, 다음과 같이 테이블 사이의 관계를 나타낼 수 있다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/92e449d5-6f5a-43dd-a16e-58f70b456fb3"/>

## 일대다 관계 

예를 들어 온라인 쇼핑몰에서 유저 한명은 여러 개의 상품을 담을 수 있다. 이러한 경우 일대다 관계가 된다. 상품을 하나도 담지 않는 경우도 있으므로 0도 포함하는 관계 화살표를 그린다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/4a016089-f9e1-446f-ab76-9568543c2f10"/> 

## 다대다 관계 

학생과 강의 사이의 관계를 생각하면, 학생도 강의를 여러 개 들을 수 있고, 강의도 여러 명의 학생을 포함할 수 있다. 이럴 때 다대다 관계가 된다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/2e1e51ec-54d2-4a3e-acab-15b82e702412"/>

위의 그림을 보면 학생_강의 라는 테이블이 중간에 껴있다. 다대다 관계는 두 개의 테이블을 직접 연결해서 구축하지 않고, 1:N, 1:M 관계를 갖는 테이블 두 개로 나눠서 구축한다. 

# 4.1.7 키 

테이블 간의 관계를 조금 더 명확하게 하고, 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다. 

<img width="500" src="https://github.com/leeeha/CS-Study/assets/68090939/db7ce478-ebb9-498a-a25d-cedab5493be0">

- 유일성: 값이 중복되지 않아 각 레코드를 유일하게 식별할 수 있는 것  
- 최소성: 최소 필드만 사용하여 키를 형성할 수 있는 것 
- 슈퍼키는 유일성이 있고 그 안에 포함된 후보키는 최소성까지 갖춘 키이다. 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다.

## 기본키 

|ID|name|
|---|---|
|PDT-0001|홍철이의 따스한 점퍼|
|PDT-0002|제호의 BMW|
|PDT-0002|제호의 BMW|
|PDT-0003|종선이의 벤츠|

기본키(Primary Key, PK)는 유일성과 최소성을 만족시키는 키이다. 이는 테이블의 데이터 중 고유하게 존재하는 속성이며, 기본키에 해당하는 데이터는 위의 ID처럼 값이 중복되면 안 된다. 

|ID|name|
|---|---|
|1|주홍철|
|2|주홍철|
|3|최범석|
|4|양기영|

위의 테이블에서 ID는 기본키로 설정할 수 있다. {ID, name}이라는 복합키를 기본키로 설정할 수 있지만 그러면 최소성을 만족시키지 않는다. 

기본키는 자연키 또는 인조키 중에 골라서 설정한다. 

### 자연키 

유저 테이블을 만든다고 하면 주민등록번호, 이름, 성별 등이 테이블의 속성이 될 수 있다. 이 중에서 이름, 성별은 중복될 수 있으므로 기본키로 부적절하고 남는 것은 주민등록번호이다. 이렇게 값이 중복되는 속성들을 제외하다가, 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키를 자연키라고 한다. 자연키는 언젠가 값이 변할 수 있다는 특징이 있다. 

### 인조키 

유저 테이블의 속성으로 주민등록번호, 이름, 성별 등을 속성으로 생각할 수 있는데 여기에 인위적으로 유저 아이디를 부여해보자. 그러면 이 아이디가 각 튜플의 고유 식별자가 된다. 오라클은 이를 sequence로, MySQL은 AUTO INCREMENT로 설정한다. 이렇게 인위적으로 생성한 키를 인조키라고 하며, 자연키와 달리 값이 바뀌지 않으며 따라서 보통 기본키는 인조키로 설정한다. 

## 외래키 

외래키(Foreign Key, FK)는 다른 테이블의 기본키를 그대로 참조하는 값으로, 개체와의 관계를 식별하는데 사용한다.

<img width="400" src="https://github.com/leeeha/CS-Study/assets/68090939/cf413ffd-765a-4f40-b277-99f9b4209b8a">

외래키는 값이 중복되어도 괜찮다. 위의 그림에서 client 테이블의 기본키인 ID가 product 테이블의 user_id라는 외래키로 설정된 것을 볼 수 있다. 그리고 외래키인 user_id는 값이 중복될 수 있음을 알 수 있다.

## 후보키 

후보키(candidate key)는 기본키가 될 수 있는 후보들이며, 유일성과 최소성을 동시에 만족시키는 키이다. 

## 대체키

대체키(alternate key)는 후보키가 두개 이상일 때 어느 하나를 기본키로 지정하고 남은 후보키들을 의미한다. 

## 슈퍼키 

슈퍼키(super key)는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키를 의미한다. 
