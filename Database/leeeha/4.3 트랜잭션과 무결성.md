# 4.3 트랜잭션과 무결성 

# 4.3.1 트랜잭션 

트랜잭션(Transaction)은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다. 데이터베이스에 접근하는 방법은 쿼리이므로, 즉 여러 개의 쿼리들을 하나로 묶는 단위를 의미한다. 

SELECT, UPDATE, INSERT, DELETE 와 같은 쿼리 연산을 수행하여 데이터베이스의 상태를 변화시키는 작업의 단위를 트랜잭션이라고 한다. 

## 트랜잭션의 특징 (ACID)

### 원자성 (Atomicity)

>"all or nothing"

- 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 한다. 
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
- 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안 된다. 만약 있다면 롤백이 일어났을 때 어떻게 해야 할지에 대한 해결 방법이 있어야 하고, 트랜잭션 전파를 신경써서 관리해야 한다. 

### 일관성 (Consistency)

- 트랜잭션의 작업 처리 결과가 항상 일관성 있어야 한다. 
- 시스템이 갖고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야 한다. 
- 데이터베이스에 기록된 모든 데이터는 여러가지 조건, 규칙에 따라 유효함을 가져야 한다. 

### 격리성 (Isolation)

- 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 어떤 하나의 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다. 
- 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다. 
- 여러 개의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 한다.

### 지속성 (Durability)

- 트랜잭션이 성공적으로 완료되었을 경우, 그 결과는 데이터베이스에 영구적으로 반영되어야 한다. 
- 데이터베이스에 시스템 장애가 발생하더라도 원래 상태로 복구하는 회복 기능이 있어야 하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다. 

cf) 체크섬: 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법 

cf) 저널링: 파일 또는 데이터베이스 시스템에 변경사항을 반영(commit)하기 전에 로깅하는 것. 트랜잭션 등 변경사항에 대한 로그를 남기는 것. 

## 커밋과 롤백 

커밋(commit)은 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어다. 트랜잭션 단위로 수행되며, 변경된 내용은 데이터베이스에 모두 영구적으로 저장된다. "커밋이 수행되었다."를 "하나의 트랜잭션이 성공적으로 수행되었다."라고도 말한다.

![image](https://github.com/leeeha/CS-Study/assets/68090939/7f7b0e45-f479-4acc-b118-780245ee63e7)

위의 그림처럼 UPDATE, DELETE, INSERT 쿼리가 하나의 트랜잭션 단위로 수행되고 이후에 데이터베이스에 영구 저장된다. 

하지만 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 할 때는 롤백(rollback)한다. 롤백이란 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 되돌리는 일(취소)을 말한다. 

이러한 커밋과 롤백 덕분에 데이터의 무결성이 보장된다. 또한, 데이터를 변경하기 전에 변경사항을 쉽게 확인할 수 있고 이런 작업들을 그룹화 할 수 있다. 

## 트랜잭션의 상태 

![image](https://github.com/leeeha/CS-Study/assets/68090939/bef24bdf-a4e9-4015-92ba-e36dc82ba088)

- 활동 (active): 트랜잭션의 활동 상태. 트랜잭션이 실행 중이며 동작 중인 상태. 
- 부분 완료 (partially committed): 트랜잭션의 커밋 명령이 도착한 상태. 트랜잭션의 커밋 이전 SQL문이 수행되고 커밋만 남은 상태.
- 완료 (committed): 트랜잭션이 정상적으로 완료된 상태. 
- 실패 (failed): 트랜잭션 실패 상태. 트랜잭션이 더 이상 정상적으로 진행될 수 없는 상태.
- 취소 (aborted): 트랜잭션 취소 상태. 트랜잭션이 취소되고 트랜잭션을 실행하기 이전 데이터로 돌아간 상태.

cf) 커밋 요청이 들어오면 부분 완료 상태가 된다. 이후 커밋을 문제없이 수행하면 완료 상태가 되고, 오류가 발생하면 실패 상태가 된다. 즉, 부분 완료는 커밋 요청이 들어왔을 때를 말하며, 완료 상태는 커밋을 정상적으로 완료한 상태를 말한다.

## 트랜잭션의 전파

트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다. 하지만 이를 매번 넘겨주기가 번거롭기 때문에 여러 트랜잭션 관련 메서드들의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다. 

```java
@Service
@Transactional(readOnly = true)
public class MemberService {
    private final MemberRepository memberRepository; 

    public MemberService(MemberRepository memberRepository){
        this.memberRepository = memberRepository; 
    }
}
```

위의 코드처럼 스프링 프레임워크에서는 @Transactional 어노테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리한다.

# 트랜잭션의 격리 수준 

트랜잭션의 격리 수준이란 트랜잭션들끼리 일관성 있는 데이터를 얼마나 허용할 것인지 정해놓은 수준이다. 즉, 트랜잭션 수행 중에 다른 트랜잭션이 해당 데이터를 조회하는 것이 가능한 정도를 결정해놓은 것이다. 

격리 수준이 높을수록 일관성은 보장되지만 그만큼 동시성이 떨어져 성능이 하락한다. 

## 트랜잭션 이상현상의 종류 

- Dirty Read: 어떤 트랜잭션에서 **아직 실행이 끝나지 않은 트랜잭션에 의한 변경사항**을 보게 되는 경우 
- Non Repeatable Read: 어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 **그 사이에 다른 트랜잭션이 수정, 삭제 연산을 수행**하여 같은 쿼리에 대해 다른 값이 나오는 경우
- Phantom Read: 어떤 트랜잭션이 같은 쿼리를 2번 실행하는데 **그 사이에 없던 레코드가 추가되어** 같은 쿼리에 대해 다른 값이 나오는 경우 

## 격리 수준의 종류 

### READ uncommitted (LEVEL 0)

- 가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다. 
- 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적이지만, 몇 개의 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데는 사용하면 좋다. 

![image](https://github.com/leeeha/CS-Study/assets/68090939/3f1380c1-16fb-42a3-9f26-c56b3b6cd460)

READ uncommitted 상태에서는 위와 같이 커밋되지 않은 상태여도 변경된 값을 다른 트랜잭션에서 읽을 수 있다. 

따라서 이때 Dirty Read, Non Repeatable Read, Phantom Read 문제가 모두 발생할 수 있다. 

### READ committed (LEVEL 1)

- 트랜잭션 수행이 완료되고 커밋된 데이터만 다른 트랜잭션에서 읽을 수 있도록 허용하는 수준이다. 
- 일반적으로 DBMS에서 기본으로 설정하는 레벨이다. 

![image](https://github.com/leeeha/CS-Study/assets/68090939/0ca1ae56-ef38-4c72-8a6c-21038e83013d)

READ committed 상태에서는 위와 같이 COMMIT 되기 전에는 UNDO 영역에 백업되어 있는 레코드에서 값을 가져온다. 

커밋이 끝난 뒤에 SELECT 하면 변경된 값이 조회될 것이다. 

READ committed 수준에서는 Dirty Read 문제가 발생하지 않는다. (커밋된 데이터만 읽을 수 있기 때문에)

하지만 다음과 같은 문제가 발생할 수 있다. 

![image](https://github.com/leeeha/CS-Study/assets/68090939/19749061-7902-46d4-b233-6f5811e07eb6)

트랜잭션 1이 COMMIT 하기 전에 트랜잭션 2의 SELECT 결과를 '제니'였다. 

하지만, 트랜잭션 1이 COMMIT 하고나서 SELECT 결과는 '태연'이었다. 

따라서, Non Repeatable Read 또는 Phantom Read 문제가 발생할 수 있다. 

### REPEATABLE READ (LEVEL 2)

- 특정 트랜잭션에서 읽고 있는 데이터를 **다른 트랜잭션에서 수정, 삭제가 불가능** 하도록 만든다. 하지만, 새로운 행을 **삽입하는 건 가능**하다. 
- 실제로 동작하는 방식은 자신의 트랜잭션 번호(id) 보다 낮은 트랜잭션 번호에서 변경된 것만 읽게 되고, 자신의 트랜잭션 번호보다 높은 트랜잭션에서 변경된 것은 UNDO 영역에 백업된 레코드를 읽게 된다. 
- UNDO 영역에 백업된 레코드가 많아지면 성능이 떨어질 수 있다. 

![image](https://github.com/leeeha/CS-Study/assets/68090939/ee29ecc5-5440-4b2b-a06d-43a03d6bde9f)

REPEATABLE READ에서는 위와 같이 자신의 트랜잭션 번호(10)보다 높은 트랜잭션 번호(12)에서 변경된 것은 UNDO 영역에 백업된 레코드로 읽게 된다.

따라서, Non Repeatable Read 문제는 발생하지 않지만 다음과 같이 Phantom Read 문제는 발생할 수 있다. 

![image](https://github.com/leeeha/CS-Study/assets/68090939/6b1213ca-f8af-4b9a-b8e3-baf90b2c5e17)

트랜잭션 2에서 전체 행의 개수를 구하는 쿼리 -- SELECT COUNT(*) -- 를 실행했을 때의 결과가 달라질 수 있다. 트랜잭션 1에서 INSERT 쿼리를 수행한 결과가 트랜잭션 2에 보이기 때문이다. 따라서, Phantom Read 문제가 발생한다. 

### SERIALIZABLE (LEVEL 3)

- 가장 단순하고 엄격한 격리 수준이다. 
- 모든 동작이 순차적으로 동작한다. 
- 특정 트랜잭션에서 읽고 있는 데이터는 다른 트랜잭션에서 수정, 삭제, 삽입 불가능하다. 
- 동시성이 떨어져 성능이 하락하기 때문에 잘 사용하지 않는다. 
- Dirty Read, Non Repeatable Read, Phantom Read 문제가 발생하지 않는다. 

# 4.3.2 무결성 

무결성(integrity)이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 

무결성이 유지되어야 데이터베이스에 저장된 값과 그 값에 해당하는 현실 세계의 값이 일치하는지에 대한 신뢰가 생긴다. 

무결성의 종류는 다음과 같다. 

|이름|설명|
|---|---|
|개체 무결성|기본키로 선택된 필드는 NULL을 허용하지 않는다.|
|참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.|
|고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어지면, 그 속성 값은 모두 고유해야 한다.|
|NULL 무결성|특정 속성에 NULL이 올 수 없다는 조건이 주어지면, 그 속성은 NULL 값을 가지면 안 된다.|

# 참고자료 

- https://code-lab1.tistory.com/51
- https://code-lab1.tistory.com/52

