# 트랜잭션과 무결성
## Transaction 이란?

*더 이상 나눌 수 없는 가장 작은 하나의 단위 ?!*

데이터베이스의 상태를 변경하는 작업 또는 한번에 수행되어야 하는 연산들을 의미한다!

**👉 병행 제어 시 처리되는 작업의 논리적 단위 !!**

예를 들어, A가 B에게 10000원을 송금을 한다고 생각하자!

A의 계좌에서 10000원을 출금하고 B의 계좌에 10000원을 입금하여야 하는데 만약 이 과정에서 문제가 생겨 A의 계좌에서 출금한 후 B의 계좌에 입금을 하지 못한 상황이 발생한다면 ?!

트랜잭션은 이 작업을 실행하기 전으로 되돌린다!!

즉, 모든 작업이 성공적으로 완료되어야 작업 결과를 적용하고, 작업 중에 어느 한 곳에서도라도 오류가 발생하면 작업 실행 전의 상태로 돌아간다.

### Transaction의 4가지 성질 👉 ACID

- **Atomicity 원자성**
    - 한 트랜잭션 내의 실행 작업은 **하나의 단위로** 처리한다.
    - 트랜잭션은 절대로 깨지지 않는 하나의 원자처럼 **하나가 전부 실행되든, 전부 실패**하도록 한다.
    - 📢 트랜잭션 단위로 여러 로직들으르 묶을 때 외부 API를 호출하는 것이 있으면 안된다.
        - 만약 있다면 롤백이 일어났을 때 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하고 트랜잭션 전파를 신경 써서 관리해야 한다.
- **Consistency 일관성**
    - 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.
    - 제약조건이나 데이터 규칙에 위반하지 않는 일관성을 의미한다.
    - 하나의 동작이 정상적인 흐름을 일관적으로 가질 수 있어야 한다는 원칙
- **Isolation 독립성(격리성)**
    - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 독립적이다.
    - 트랜잭션 수행시에 다른 트랜잭션 작업이 끼어들 수 없고 각 트랜잭션을 독립적으로 수행해야 한다.
    - 격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장한다. 자세한 설명은 아래에서 하겠다.
- **Durability 영속성**
    - 트랜잭션을 성공적으로 마치면 결과가 항상 저장된다.
    - 트랜잭션 동작 성공 후 commit 된다면 그 결과가 영원히 반영되어야 한다.

### 트랜잭션을 제어하는 명령어 👉 COMMIT, ROLLBACK, SAVEPOINT

- 커밋(COMMIT)
    - 변경된 데이터를 테이블에 영구적으로 반영하는 것
    - 커밋 전에는 단지 메모리 Buffer에만 영향을 받았기 때문에, 데이터의 변경 이전 상태로 복구 가능하다! (커밋 후에는 변경사항이 DB에 반영되며, 이전 데이터는 영원히 잃어버리게 된다.)
- **롤백(ROLLBACK)**
    - 테이블 내 입력한 데이터나, 수정한 데이터, 삭제한 데이터에 대하여 **커밋 이전에는 변경사항을 취소**할 수 있는데, 이때 롤백 기능을 사용한다!
    - 롤백은 데이터 변경 사항이 취소되어 데이터의 이전 상태로 복구되며, 관련된 행에 대한 잠금(Locking)이 풀리고 다른 사용자들이 데이터 변경을 할 수 있게됨을 의미한다.
- **저장점(SAVEPOINT)**
    - 저장점을 정의하면 롤백할 때 트랜잭션에 포함된 전체 작업을 롤백하는 것이 아니라 현시점에서 SavePoint까지의 트랜잭션만 롤백하고 실패한 부분에 대해서만 다시 실행할 수 있다. (일부 툴에서는 지원 안될 수 있다!)

### 트랜잭션 전파(Transaction Propagation)

***👉 어떤 트랜잭션이 동작중인 과정에서 다른 트랜잭션을 실행할 경우 어떻게 처리하는가에 대한 개념***

예시 상황을 보면,

> 게시판에 글을 작성하는 기능을 하는 로직을 생각해 보자. <br>글을 임시 저장하는 기능이 글 작성 중간 중간에 수행되고 동시에 로깅을 해야하는 상황이다. 이때 로깅 작업에서 예외가 발생했다. 이때 트랜잭션 전파 옵션이 Default이면 Rollback이 진행될 때, 임시 저장되는 기능도 함게 Rollback된다.
> 

위의 예시 상황에서는 임시 저장 기능은 Rollback이 되선 안된다.<br> 그럼 기본 트랜잭션 옵션을 변경해줘야 한다! 👉 로깅 작업과 임시저장 작업이 **개별적인 트랜잭션 단위**에서 움직이게 바꿔줘야 한다!!

아래는 트랜잭션 전파 속성 종류이다.

- **REQUIRED**
    - Default 속성
    - 기본적으로 부모 트랜잭션이 있으면 부모 트랜잭션에 종속
    - 부모 트랜잭션이 없을 경우에는 새로운 트랜잭션 생성
- **REQUIRES_NEW**
    - Default 속성
    - 기본적으로 부모 트랜잭션이 있으면 부모 트랜잭션에 종속
    - 부모 트랜잭션이 없을 경우에는 새로운 트랜잭션 생성
- **SUPPORTS**
    - 부모 트랜잭션이 있을 때만 해당 부모 트랜잭션에 종속
    - 부모 트랜잭션이 없으면 트랜잭션이 적용되지 않는다.
- **NOT_SUPPORTED**
    - 부모 트랜잭션이 있으면 부모 트랜잭션을 대기시키고 트랜잭션 없이 실행
    - 부모 트랜잭션이 없으면 트랜잭션 없이 실행된다.
- **MANDATORY**
    - 부모 트랜잭션이 있을 때만 해당 부모 트랜잭션에 종속
    - 부모 트랜잭션이 없으면 예외가 발생한다.
- **NEVER**
    - 트랜잭션이 적용되면 안되는 경우에 사용
    - 부모 트랜잭션이 있으면 예외가 발생한다.
    - 부모 트랜잭션이 없으면 트랜잭션 없이 실행된다.
- **NESTED**
    - 부모 트랜잭션이 있으면 새로운 트랜잭션 생성
    - REQUIRED_NEW와는 다르다.
    - 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다.
    - 자식 트랜잭션이 실패하면 부모 트랜잭션은 Rollback되지 않는다.
    - 부모 트랜잭션이 실패하면 자식 트랜잭션은 Rollback 된다.

Spring에서는 다음과 같이 사용한다!

```java
@Transactional
public List<Crew> update(List<Crew> crews) {
	System.out.println("Transaction1: " + TransactionSynchronizationManager.getCurrentTransactionName());
    crewRepository.deletAll();
    return saveAll(crews);
}
  
@Transactional(propagation = Propagation.REQUIRES_NEW)
public List<Crew> saveAll(List<Crew> crews) {
    System.out.println("Transaction2: " + TransactionSynchronizationManager.getCurrentTransactionName());
    return crewRepository.saveAll(crews);
}
```

### 트랜잭션 격리 수준(Isolation Level)

*트랜잭션의 격리 수준(Isolation Level)이란 **여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것***

트랜잭션의 격리 수준은 다음과 같다.

- **ERIALIZABLE (직렬화 가능)**
    - 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
    - 가장 높은 데이터 정합성을 갖으나, 성능은 가장 떨어진다.
    - 이 격리 수준에서는 단순한 SELECT 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없게된다.
- **REPEATABLE READ (반복 가능한 읽기)**
    - 특정 행을 조회할 때 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준
    - 하지만, SERIALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다. 👉 팬턴 리드 현상 발생 가능!!
- **READ COMMITTED (커밋된 읽기)**
    - 커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용하는 격리 수준
    - 즉, 특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다.
    - 가장 많이 사용되는 격리 수준
    - 특정 트랜잭션에서 데이터가 변경되었으나, 아직 커밋되지 않은 상태라면 **다른 트랜잭션에서는 해당 데이터에 접근했을 때 트랜잭션 시작 전 데이터**를 읽어온다. 커밋이 된 이후에서야 변경된 데이터 값을 읽어올 수 있다. 👉 팬텀 리드 현상, 반복 불가능한 조회 발생 가능!!
- **READ UNCOMITTED (커밋되지 않은 읽기)**
    - 커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용하는 격리 수준
    - 데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다. 데이터를 어림잡아 집계하는 등의 연산에서 사용하면 좋다.
    - 더티 리드, 반복 불가능한 조회, 팬텀 리드 발생 가능!!!

아래로 갈수록 격리 수준이 낮아지며, 동시 처리 성능이 높아진다.

반면 위로 갈수록 격리 수준이 높아지며, 동시 처리 성능은 낮아지지만 데이터 부정합 문제가 발생할 확률이 줄어든다.

👉 즉, 데이터 정합성과 성능은 반비례한다!

트랜잭션 격리 수준에 따라 발생할 수 있는 문제점들..

- **더티 리드(Dirty Read)**
    - 특정 트랜잭션에 의해 데이터가 변경되었지만, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제
- ****반복 불가능한 조회 (Non-Repeatable Read)****
    - 같은 트랜잭션 내에서 같은 데이터를 여러번 조회했을 때 읽어온 데이터가 다른 경우
- ****팬텀 리드 (Phantom Read)****
    - Non-Repeatable Read의 한 종류로 조회해온 결과의 행이 새로 생기거나 없어지는 현상

## 데이터 무결성(Data Integrity)

무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며, 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생긴다!!

> ***정확성** 👉 중복이나 누락이 없는 상태<br>
**일관성** 👉 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태*
> 

만약 데이터베이스에서 데이터 무결성 설계를 하지 않는다면 테이블에 중복된 데이터 존재, 부모와 자식 데이터 간의 논리적 관계 깨짐, 잦은 에러와 재개발 비용 발생 등과 같은 문제가 발생할 것입니다.

### 데이터 무결성 제약 조건의 종류

- **개체 무결성(Entity Integrity)**
    - 기본 키 제약이라고도 하며, 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 하는 조건
    - 기본 키(Primary Key)에는 Null 값이 올 수 없음
    - 기본 키는 테이블 내에 오직 하나의 값만 존재해야 함(하나의 테이블 내에 동일한 기본 키를 가진 레코드는 존재할 수 없음)
- ****참조 무결성(Referential integrity)****
    - 외래 키 제약이라고도 하며, 테이블 간의 참조 관계를 선언하는 제약조건
    - 외래 키(Foreign Key)의 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함
    - 외래 키 속성은 참조할 수 없는 값을 지닐 수 없음(즉, 외래 키 속성 값이 상위 테이블의 인스턴스에 반드시 존재하거나 Null이어야 함)
- ****도메인 무결성(Domain integrity)****
    - 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, Null 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건
- ****Null무결성(Null integrity)****
    - 테이블의 특정 속성 값이 Null이 될 수 없게 하는 조건
- ****고유 무결성 (Unique integrity)****
    - 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야 하는 조건
- ****키 무결성 (Key integrity)****
    - 하나의 테이블에는 적어도 하나의 키가 존재해야 하는 조건
- ****관계 무결성 (Relationship integrity)****
    - 테이블의 어느 한 레코드의 삽입 가능 여부 또는 한 테이블과 다른 테이블의 레코드들 사이의 관계에 대한 적절성 여부를 지정한 조건

### 무결성 제약조건의 장단점

- **장점**
    - 스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고, 데이터베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없음
- **단점**
    - 프로그래밍 작업이 훨씬 복잡해지고, 무결성 제약조건을 반복해서 구현해야 하고, 무결성 제약조건들 간에 서로 충돌이 발생할 수 있음

---

### 참고자료

- 면접을 위한 CS 전공 지식노트
- [https://velog.io/@myspy/Transaction-전파가-뭡니까](https://velog.io/@myspy/Transaction-%EC%A0%84%ED%8C%8C%EA%B0%80-%EB%AD%A1%EB%8B%88%EA%B9%8C)
- https://hudi.blog/transaction-isolation-level/
- https://cocoon1787.tistory.com/778