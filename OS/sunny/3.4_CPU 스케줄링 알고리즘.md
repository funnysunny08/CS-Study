# CPU 스케줄링 알고리즘

## CPU 스케줄링

> **CPU 스케줄링이란?! 🤔**
*운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것*


### **프로세스 우선순위**

예를 들어,

입출력 작업이 많은 프로레스(=입출력 집중 프로세스)의 우선순위는
CPU 작업이 많은 프로세스(=CPU 집중 프로세스)의 우선순위보다 높다!

*👉 입출력 집중 프로세스는 어차피 CPU는 잠깐만 사용하면 되니깐!!*

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/bff96ba1-9e0b-4e9b-acf4-dbca200c0374)

이러한 우선순위는 프로세스의 PCB에 저장된다!!

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/5154dea3-09ab-462e-8e5d-1f364a5e6549)

위의 `priority` 를 보면 알다시피 우선순위를 직접 확인할 수 있다!

이처럼 프로세스마다 우선순위가 있긴 하지만 일일이 모든 프로세스의 PCB를 확인하여 우선순위를 파악하는 것은 비효율적!!!!

그래서 운영체제가 사용하는 것이 **스케줄링 큐!!**

> **스케줄링 큐?!🤔**
*어떤 자원을 이용하고 싶어하는 프로세스들이 서는 줄*


![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/c7c684ca-dd07-484f-8837-90976f1b3309)

✋ 스케줄링에서의 큐는 반드시 선입선출 방식일 필요는 없다!

### 스케줄링 큐 - 준비 큐와 대기 큐

***준비 큐** 👉 CPU를 이용하고자 하는 프로세스들이 서는 줄*

***대기 큐** 👉 입출력 장치를 이용하고 하는 프로세스들이 서는 줄*

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/266d139f-20a2-4512-947e-27394b984504)

동시에 실행중인 프로세스가 여러 개가 있다 가정했을 때,

CPU 자원은 한정되어 있기 때문에 이 프로세스들끼리 CPU를 번갈아 가며 써야 한다.

그래서 이 프로세스들은 **준비 상태**로 접어들어서 CPU의 할당을 기다리게 된다.

그리고 준비 상태에 접어든 프로세스 중에서 자신의 차례가 되면 디스패치돼서 CPU를 할당받아 실행을 하게 된다!! (→ **실행 상태**)

그리고 자신의 실행 차례가 다 끝나면 (= 타임아웃 인터럽트) 다시 **준비 상태**에 접어들게 된다. 

이후 다음으로 우선순위가 높은 프로세스가 디스패치가 돼서 실행상태가 되고 ~~ 이런 식으로 반복하게 된다! 

혹은 쭉 실행을 하다가 **입출력 작업을 해야 될 때가 되면** 이때부터는 CPU를 쓸 필요가 없기 때문에 **대기 상태**에 들어가 대기 큐에 삽입된다.

이후 **입출력 작업이 끝나서** 입출력 완료 인터럽트를 받았으면 다시 **준비 상태**에 접어들 수 있게 된다. (대기 큐 → 준비 큐)

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/e3b8e643-8ca2-458f-a433-40a1b69a57ab)

***대기 큐** : 같은 장치를 요구한 프로세스들은 같은 큐에서 대기*

입출력이 완료돼서 입출력 완료 인터럽트가 발생하면, 
운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고 이 PCB의 상태를 **대기 상태**에서 **준비 상태**로 변경한 다음에 대기 큐에서 제거하고 준비 큐로 넣어주게 된다! 

*👉 운영체제는 프로세스를 이러한 흐름으로 관리한다!!!!*

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/fd9962a5-baa6-4e7d-beb7-fa29828913bc)

## 선점형과 비선점형 스케줄링

***만약 실행 상태의 프로세스가 있는데, 어떤 프로세스가 갑자기 CPU를 요청한다!***

이럴 때 두가지 선택이 존재한다.

1. 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
***👉 선점형 스케줄링 (preemptive scheduling)***
2. 현재 CPU를 사용 중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기
***👉 비선점형 스케줄링 (non-preemptive scheduling)***

### 선점형 스케줄링

어떤 프로세스 하나가 CPU 자원 하나를 독점해서 쓸 수 없는 스케줄링

👍 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다

👎 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

### 비선점형 스케줄링

어느 한 프로세스가 자원을 이용하고 있다면, 그 프로세스가 종료되거나 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식

👍 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다

👎 모든 프로세스가 골고루 자원을 이용하기 어렵다

## CPU 스케줄링 알고리즘

### 1. 선입 선처리 스케줄링, FCFS (First Come First Served)

- 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
- 먼저 CPU를 요청한 프로세스부터 CPU 할당
- 👎 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (= 호위 효과)

> **호위 효과**
먼저 도착한 프로세스가 CPU에서 수행되는 버스트 시간이 매우 길면, 그 다음 도착한 프로세스가 첫번째 프로세스가 끝날 때까지 매우 긴 시간을 기다리게 되는 것!


이러한 호위 효과를 방지하려면?! → `SJF`

### 2. 최단 작업 우선 스케줄링, SJF (Shortest Job First)

- CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
- CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식
- SJF는 선점형, 비선점형 모두 구현 가능! 
But, 기본적으로는 비선점형으로 구분함!

### 3. 라운드 로빈 스케줄링, RR (Round Robin)

- 선입 선처리 스케줄링 + 타임 슬라이스 (time slice)

> **타임 슬라이스**
각 프로세스가 CPU를 사용할 수 있는 정해진 시간
> 
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
    - 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용
    - 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입 (문맥 교환)
- 타임 슬라이스의 크기가 중요!!

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/e250d021-dda7-4457-94ed-d8e915e0f59e)

### 4. 최소 잔여 시간 우선 스케줄링, SRT (Shortest Remaining Time)

- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
- **정해진 시간만큼 CPU를 이용**하되, 다음으로 CPU를 사용할 프로세스로는 **남은 작업 시간이 가장 적은 프로세스** 선택

### 5. 우선순위 스케줄링

- 프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
- 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 ⊂ 우선순위 스케줄링
- 👎 우선순위 스케줄링의 근본적인 문제점, **기아(starvation) 현상**
    - 우선순위 높은 프로세스만 주구장창 실행
    - 우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기
- 이러한 기아 현상을 방지하기 위한 기법 👉 **에이징(aging)**
    - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
    - 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법
        - 우선순위가 낮아도 언젠가는 우선순위가 높아진다!

### 6. 다단계 큐 스케줄링, Multilevel queue

- 우선순위 스케줄링의 발전된 형태
- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
    - 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
    - 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리
- 이렇게 큐를 여러 개 두면?! → **프로세스 유형별로 우선순위를 구분**하는 것이 쉬워진다
    - 가령 어떤 큐에는 우선순위가 비교적 높아야 하는 입출력 집중 프로세스가 삽입될 수 있고 
    어떤 큐에는 우선순위가 비교적 낮아도 상관없는 CPU 집중 프로세스가 삽입될 수 있고, 또 어떤 큐에는 선입선처리, 라운드로빈, 등등~
    - 이런 식으로 ***큐 별로 스케줄링을 달리 적용해서 프로세스를 유형별로 처리하는 것***이 쉬워진다!!
- 👎 프로세스가 큐간의 이동이 불가능!
    - 우선순위가 낮은 프로세스는 계속해서 우선순위가 낮은 큐에 머물 수 밖에 없고 다시 한 번 기아현상이 발생할 수 있다..
    - 이것을 해결하기 위한 것이?! → `다단계 피드백 큐 스케줄링`

### 7. 다단계 피드백 큐 스케줄링, Multilevel feedback queue

- 다단계 큐 스케줄링의 발전된 형태
- 큐 간의 이동이 가능한 다단계 큐 스케줄링
- 다단계 큐 스케줄링에서는 기본적으로 큐 간의 이동이 불가
    - 우선순위 낮은 프로세스는 계속해서 실행 연기 우려
    - 기아 현상 발생 가능
- ***어떻게?!***
    - 새롭게 준비 상태가 된 프로세스가 있으면 일단 해당 프로세스를 가장 우선 순위가 높은 큐에 삽입
    - 그리고 타임 슬라이스만큼 CPU를 할당받아 실행하게 된다
    - 이때 실행이 아직 안 끝났다면, 우선순위가 다음으로 높은 곳에 삽입
    - 👉 이런 식으로 우선순위가 점차 낮은 큐로 이동하는 것…
- CPU를 많이 써야 하는 CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고,
CPU를 상대적으로 많이 쓸 필요가 없는 입출력 집중 프로세스의 우선순위는 상대적으로 높아지게 된다!
- 다단계 피드백 큐에서도 **에이징 기법**을 적용할 수 있다!
- CPU 스케줄링 방식의 가장 일반적인 형태!

![image](https://github.com/funnysunny08/Algorithm-java/assets/88873302/b966f47f-10c6-4edf-832a-184f6f605f31)

---

### 📚 참고 자료
- https://www.youtube.com/watch?v=CdrozYcVccE
- https://www.youtube.com/watch?v=w1z6WCyMdhQ