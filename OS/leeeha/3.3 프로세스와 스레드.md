# 3.3 프로세스와 스레드

- 프로세스 (process): 컴퓨터에서 실행되고 있는 프로그램 (task라고도 함) 
  - 프로세스는 운영체제에서 작업의 단위이다.
  - 프로세스는 자신의 작업을 수행하기 위해 특정한 리소스 (CPU time, memory, files, and I/O devices)을 필요로 하며, 운영체제는 이를 관리하는 역할을 한다.
- 스레드 (thread): 프로세스 내 작업의 흐름

프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어나고, 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행한다.

<img width="500" src="https://velog.velcdn.com/images/jxlhe46/post/37eb89f4-cc35-4812-afcc-e165d6102369/image.png"/>

# 3.3.1 프로세스와 컴파일 과정 

프로세스는 프로그램이 메모리에 올라가 인스턴스화 된 것을 말한다. 예를 들어, 프로그램은 구글 크롬 프로그램 (chrome.exe)과 같은 실행 파일이며, 이를 두번 클릭하면 구글 크롬 프로세스로 변환되는 것이다. 

실행 파일을 만드는 과정은 언어마다 다를 수 있으며 컴파일 언어인 C언어 기반의 프로그램 기준으로 설명하면, 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행 파일을 만들게 된다.

## 프로세스의 컴파일 과정 

참고: https://bradbury.tistory.com/226 

### 컴파일의 정의 

컴파일은 인간이 이해할 수 있는 언어로 작성된 소스 코드(고수준 언어: C, C++, JAVA 등)를 CPU가 이해할 수 있는 언어(저수준 언어: 기계어)로 번역하는 작업을 말한다. 컴퓨터는 0과 1로 이루어진 기계어만 이해할 수 있기 때문에 우리가 작성한 소스 코드를 기계어로 번역하는 컴파일 과정이 필요하다. 

소스 코드는 컴파일을 통해 기계어로 이루어진 실행 파일이 된다. 운영체제가 이 실행 파일을 메모리에 적재하면 프로그램이 동작하며 이렇게 실행 중인 프로그램을 프로세스라고 한다.

### 컴파일 과정 

![image](https://github.com/leeeha/CS-Study/assets/68090939/2bf8fb84-2555-41dc-bc99-b8d9bd2e6967) 

컴파일은 4가지 단계 (전처리 - 컴파일 - 어셈블리 - 링킹)로 나누어진다. 

이 4단계를 합쳐서 컴파일 또는 빌드라고 부르는데, 보통 빌드는 컴파일보다 넓은 의미(빌드 = 컴파일 + 링킹)로 사용된다. 

### 전처리 과정 

<img width="400" src="https://github.com/leeeha/CS-Study/assets/68090939/8f7a7ccf-881e-4bfd-b152-c27c1eaf833e"/>

전처리 과정은 **전처리기(Preprocessor)를 통해 소스코드 파일(*.c)을 전처리된 소스코드 파일(*.i)로 변환**하는 과정이다. 

이 과정에서 대표적으로 3가지 작업을 수행한다. 

- 주석 제거
- 헤더 파일 삽입: #include 지시문을 만나면 해당 헤더 파일에 있는 모든 내용을 복사하여 소스코드에 삽입한다. 즉, 헤더 파일은 컴파일 되기 전에 소스코드 파일 내에 전부 복사된다. 헤더 파일에 선언된 함수 프로토타입은 나중에 링킹 과정에서 실제로 함수가 정의되어 있는 오브젝트 파일과 결합하게 된다. 
- 매크로 치환 및 적용: 소스코드에서 #define 지시문에 정의된 매크로와 동일한 문자열을 만나면 #define에 정의된 내용으로 치환한다. 즉, #define에 정의된 매크로들을 찾아서 전부 그 값으로 바꿔준다.

### 컴파일 과정 

<img width="400" src="https://github.com/leeeha/CS-Study/assets/68090939/02ec5e67-8041-4f10-a8ba-1ce1576d06f6"/>

컴파일 과정은 **전처리된 소스코드(*.i)를 컴파일러(Complier)를 통해 어셈블리어 파일(*.s)로 변환**하는 과정이다. 

이 과정에서 우리가 일반적으로 컴파일 하면 떠올리는 언어의 문법 검사가 이루어진다. 또한 정적 영역 (데이터 영역, 코드 영역)에 메모리를 할당한다. 

### 어셈블리 과정 

<img width="400" src="https://github.com/leeeha/CS-Study/assets/68090939/7df5391b-0701-4b98-9bde-0d258aa67075"/>

어셈블리어는 기계어를 사람이 이해할 수 있게 부호화 한 것으로 기계어와 일대일로 매칭된다. 

어셈블리 과정은 **어셈블러(Assembler)를 통해 어셈블리어 파일(*.s)을 오브젝트 파일(*.o)로 변환**하는 과정이다. 

어셈블리 코드는 더 이상 사람이 알아볼 수 없는 기계어로 변환되는데 이를 오브젝트 코드라고 부른다. 오브젝트 코드로 구성된 파일이 오브젝트 파일이며, 특정한 파일 포맷을 가진다.

cf) 오브젝트 파일 포맷의 종류는 Windows의 경우 PE(Portable Executable), Linux의 경우 ELF(Executable and Linking Format)로 나눠진다. 

### 링킹 과정

<img width="400" src="https://github.com/leeeha/CS-Study/assets/68090939/cb55f1c7-83a7-42db-938a-61e127014731"/>

링킹 과정은 **링커(Linker)를 통해 오브젝트 파일(*.o)들을 묶어서 실행 파일로 만드는 과정**이다. 이 과정에서 **오브젝트 파일들과 프로그램에서 사용하는 라이브러리 파일들을 링크(연결)하여 하나의 실행 파일**을 만든다. 

이때 라이브러리를 링크하는 방법에 따라 정적 링킹, 동적 링킹으로 나눌 수 있다.

**정적 라이브러리** 

프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식이다.

<img width="250" src="https://github.com/leeeha/CS-Study/assets/68090939/5a284714-a30a-48cb-9b19-b336057a13d2"/>

- 👍 실행 파일이 정적 라이브러리 내용을 모두 복사해서 가지고 있으므로, 프로그램 실행 시 별도의 라이브러리가 필요하지 않다. 즉, 실행 파일만 있으면 프로그램이 동작하기 때문에 이식성이 좋고 안정적이다. 
- 👎 실행 파일이 라이브러리 내용을 복사해서 갖고 있으므로, 라이브러리 내용이 수정되면 파일 전체를 다시 컴파일하여 재배포 해야 한다. 
- 👎 실행 파일이 라이브러리의 모든 내용을 포함하고 있는 만큼 실행 파일의 크기가 커진다. 
- 👎 같은 라이브러리를 가진 여러 프로그램이 동시에 실행되는 경우, 같은 코드가 중복되어 메모리 자원을 낭비한다. 
- 👎 정적 라이브러리 전체를 링킹하므로 사용하지 않는 함수들까지 전부 다 프로그램에 포함된다. 

이런 단점을 보완하기 위해 동적 라이브러리가 존재한다. 

**동적 라이브러리**

프로그램 실행 시 필요할 때만 DLL(Dynamic Linking Library)이라는 함수 정보를 참조하여 라이브러리를 사용하는 방식이다. 

<img width="250" src="https://github.com/leeeha/CS-Study/assets/68090939/15113567-a5e9-49ad-8b56-787555f97e52"/>

동적 라이브러리는 링커가 라이브러리 내용을 복사하지 않고 해당 내용의 주소만 갖고 있다가, 런타임에 실행 파일과 라이브러리가 메모리에 올라갈 때 해당 주소로 가서 필요한 내용만 가져오는 방식이다. 

- 👍 정적 라이브러리 보다 실행파일 크기가 작아지고, 여러 프로그램이 동적 라이브러리를 메모리에 올려놓고 공유해서 사용하기 때문에 메모리 자원을 효율적으로 사용할 수 있다. 
- 👍 라이브러리에 수정할 내용이 있으면 실행 파일을 다시 컴파일 할 필요 없이 동적 라이브러리만 다시 컴파일 하여 재배포 할 수 있다. 
- 👎 동적 라이브러리를 사용하는 실행 파일은 실행 시 동적 라이브러리가 필요하다. (동적 라이브러리가 제대로 링크되어 있지 않거나 버전이 안 맞으면 제대로 실행되지 않을 수 있다.) 즉, 외부 의존도가 생기며 이식성이 낮아진다. 
- 👎 동적 라이브러리를 사용하면 매번 프로그램 영역에서 라이브러리가 저장된 주소로 이동하는 과정이 필요하므로 약간의 성능 감소가 발생할 수 있다. 

컴파일 과정에서 연쇄적으로 사용되는 개발 도구들(전처리기 - 컴파일러 - 어셈블러 - 링커)을 묶어서 툴체인(toolchain)이라고도 부른다. 

# 3.3.2 프로세스의 상태 

프로세스가 실행될 때, 그 상태가 바뀌는데 이를 프로세스의 생명 주기라고 한다. 

![](https://velog.velcdn.com/images/jxlhe46/post/1d27486e-0e77-4eaf-ad31-41aeef603119/image.png)

- New: 새로운 프로세스가 생성된 상태 ex) fork()
- Running: CPU를 점유하여 프로그램을 실행하고 있는 상태  
- Waiting: 입출력 연산이 완료될 때까지 Waiting Queue에서 대기하고 있는 상태 
- Ready: CPU를 점유할 준비가 다 되어서 Ready Queue에서 대기하고 있는 상태 
- Terminated: 프로세스가 종료된 상태 ex) exit(), return 0;

# 3.3.3 프로세스의 메모리 구조 

운영체제는 프로세스에 적절한 메모리를 할당하는데 그 메모리의 구조는 다음과 같다. 

![](https://velog.velcdn.com/images/jxlhe46/post/fc625f6f-d430-4fdd-a8d3-4aaae20eae42/image.png)

위에서부터 스택(stack) 힙(heap), 데이터 영역(BSS segment, Data segment), 코드 영역(code segment)으로 나뉜다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다. 

## 스택과 힙 

스택과 힙은 런타임 시 메모리가 할당된다. (동적 할당)

스택은 함수 매개변수, 리턴 주소, 지역 변수 등 함수 호출에 사용되는 임시적인 데이터를 저장하는 메모리 영역이다. (참고로, 재귀함수가 호출될 때는 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않는다.) 

힙은 프로그램이 실행되고 있는 런타임에 동적으로 할당되는 메모리 영역이다. malloc(), free() 등의 함수로 관리할 수 있으며, 동적으로 관리되는 자료구조의 경우 힙 영역을 사용한다. 예를 들어, C++의 vector 컨테이너는 내부적으로 힙 영역을 사용한다. 

## 데이터 영역과 코드 영역 

이 영역은 컴파일 타임에 메모리가 할당된다. (정적 할당)

데이터 영역은 BSS(Block Started by Symbol) segment, Data segment로 나뉘는데

- BSS 세그먼트에는 0으로 초기화 되어 있거나 어떤 값으로도 초기화 되어 있지 않은 전역 변수가 할당된다. 
- Data 세그먼트는 0이 아닌 값으로 초기화 된 전역 변수가 할당된다. 

코드 영역에는 실행 가능한 코드들이 들어간다. 

C언어 코드로 예시를 살펴보면 다음과 같다. 

<img width="750" src="https://velog.velcdn.com/images/jxlhe46/post/0c95e7e0-f2b9-4fbe-a20d-8ae73dc1b929/image.png"/> 

<img width="750" src="https://velog.velcdn.com/images/jxlhe46/post/e7dc643a-dad7-4bf1-9d3b-53e1e3fb4de9/image.png"/> 

# 3.3.4 PCB 

PCB (Process Control Block)은 운영체제에서 프로세스와 관련된 모든 정보를 저장하고 있는 구조체를 말한다. 프로세스 제어 블록이라고도 하는데, 프로세스가 생성되면 운영체제는 해당 프로세스의 PCB를 생성한다. 

프로그램이 메모리에 올라가 실행되면 프로세스가 되고, 위에서 설명한 스택, 힙 등의 구조를 기반으로 프로세스 주소 값들에 메모리가 할당된다. 그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리된다. 이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리된다. 

## PCB의 구조 

PCB는 다음과 같은 정보로 이루어져 있다. 

- **프로세스 상태: New, Running, Waiting, Ready, Terminated**
- 프로세스 ID: 프로세스 자신의 ID, 자식 프로세스의 ID 
- 프로세스 권한: 컴퓨터 자원 또는 입출력 장치에 대한 권한 정보 
- **프로그램 카운터: 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터** 
- CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보 
- CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보 
- 계정 정보: 프로세스 실행 시 CPU 사용량, 실행한 유저의 계정 정보 
- 입출력 상태 정보: 프로세스에 할당된 입출력 장치들의 목록 

![](https://velog.velcdn.com/images/jxlhe46/post/e7952db1-2c4f-4b65-8319-222d9bebb848/image.png) 

## 컨텍스트 스위칭 

프로세스가 사용되고 있는 상태를 문맥이라고 하는데, 이 정보는 다 PCB에 저장되어 있다. 따라서 운영체제 입장에서 문맥, 컨텍스트는 결국 PCB를 의미한다고 볼 수 있다. 

한 프로세스에 할당된 시간이 끝나거나 인터럽트가 발생하면 이러한 PCB가 서로 교환된다. 이를 컨텍스트 스위칭 (context switching)이라고 한다. 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복원하는 식으로 진행된다. 

컴퓨터의 많은 프로세스가 동시에 구동되는 것처럼 보이는 이유는 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 진행되기 때문이다. (싱글코어 기준) 

![](https://velog.velcdn.com/images/jxlhe46/post/43e2fae9-61fe-497b-8431-06ca79be34f8/image.png) 

위의 그림에서 프로세스 P0가 실행되다가 인터럽트나 시스템 콜이 발생하면 그 상태가 PCB0에 저장되고, 프로세스 P1이 실행된다. 즉, PCB1으로부터 P1의 상태가 복원된다. 그러다가 다시 인터럽트가 발생하면, 이번에는 P1의 상태가 PCB1에 저장되고 P0의 상태는 PCB0로부터 복원된다. 이게 바로 여러 프로세스 간의 문맥 교환 (컨텍스트 스위치)이다. 

컨텍스트 스위칭이 일어날 때 유휴 시간 (idle time)이 발생하는 걸 볼 수 있다. 이뿐만 아니라 컨텍스트 스위칭이 일어날 때 프로세스가 갖고 있는 메모리 주소가 그대로 유지되면 잘못된 주소 변환이 생기므로 캐시를 클리어 하는 과정이 필요하다. 이를 캐시미스라고 한다. 

### 스레드에서의 컨텍스트 스위칭 

참고로 스레드에서도 컨텍스트 스위칭이 일어나는데, 스레드는 스택 영역을 제외한 모든 메모리를 서로 공유하기 때문에 스레드 컨텍스트 스위칭은 프로세스보다 비용도 시간도 더 적게 든다. 

# 3.3.5 멀티프로세싱 

# 3.3.6 스레드와 멀티스레딩 

# 3.3.7 공유 자원과 임계 영역 

# 3.3.8 교착 상태 
