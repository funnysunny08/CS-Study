# 3.3 프로세스와 스레드

- 프로세스 (process): 컴퓨터에서 실행되고 있는 프로그램 (task라고도 함) 
  - 프로세스는 운영체제에서 작업의 단위이다.
  - 프로세스는 자신의 작업을 수행하기 위해 특정한 리소스 (CPU time, memory, files, and I/O devices)을 필요로 하며, 운영체제는 이를 관리하는 역할을 한다.
- 스레드 (thread): 프로세스 내 작업의 흐름

프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어나고, 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행한다.

<img width="500" src="https://velog.velcdn.com/images/jxlhe46/post/37eb89f4-cc35-4812-afcc-e165d6102369/image.png"/>

# 3.3.1 프로세스와 컴파일 과정 

프로세스는 프로그램이 메모리에 올라가 인스턴스화 된 것을 말한다. 예를 들어, 프로그램은 구글 크롬 프로그램 (chrome.ext)과 같은 실행 파일이며, 이를 두번 클릭하면 구글 크롬 프로세스로 변환되는 것이다. 

실행 파일을 만드는 과정은 언어마다 다를 수 있으며 컴파일 언어인 C언어 기반의 프로그램 기준으로 설명하면, 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행 파일을 만들게 된다. 

👉 참고: https://bradbury.tistory.com/226 

- 정적 라이브러리: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식. 시스템 환경 등 외부 의존도가 낮은 건 장점이지만, 코드 중복 등 메모리 효율성이 떨어진다는 단점이 있다. 
- 동적 라이브러리: 프로그램 실행 시 필요할 때만 DLL(Dynamic Linking Library)이라는 함수 정보를 참조하여 라이브러리를 사용하는 방식. 메모리 효율성이 높아지지만, 외부 의존도도 높아지는 단점이 있다. 

# 3.3.2 프로세스의 상태 

프로세스가 실행될 때, 그 상태가 바뀌는데 이를 프로세스의 생명 주기라고 한다. 

![](https://velog.velcdn.com/images/jxlhe46/post/1d27486e-0e77-4eaf-ad31-41aeef603119/image.png)

- New: 새로운 프로세스가 생성된 상태 ex) fork()
- Running: CPU를 점유하여 프로그램을 실행하고 있는 상태  
- Waiting: 입출력 연산이 완료될 때까지 Waiting Queue에서 대기하고 있는 상태 
- Ready: CPU를 점유할 준비가 다 되어서 Ready Queue에서 대기하고 있는 상태 
- Terminated: 프로세스가 종료된 상태 ex) exit(), return 0;

# 3.3.3 프로세스의 메모리 구조 

운영체제는 프로세스에 적절한 메모리를 할당하는데 그 메모리의 구조는 다음과 같다. 

![](https://velog.velcdn.com/images/jxlhe46/post/fc625f6f-d430-4fdd-a8d3-4aaae20eae42/image.png)

위에서부터 스택(stack) 힙(heap), 데이터 영역(BSS segment, Data segment), 코드 영역(code segment)으로 나뉜다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다. 

## 스택과 힙 

스택과 힙은 런타임 시 메모리가 할당된다. (동적 할당)

스택은 함수 매개변수, 리턴 주소, 지역 변수 등 함수 호출에 사용되는 임시적인 데이터를 저장하는 메모리 영역이다. (참고로, 재귀함수가 호출될 때는 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않는다.)

힙은 프로그램이 실행되고 있는 런타임에 동적으로 할당되는 메모리 영역이다. malloc(), free() 등의 함수로 관리할 수 있으며, 동적으로 관리되는 자료구조의 경우 힙 영역을 사용한다. 예를 들어, C++의 vector 컨테이너는 내부적으로 힙 영역을 사용한다. 

## 데이터 영역과 코드 영역 

이 영역은 컴파일 타임에 메모리가 할당된다. (정적 할당)

데이터 영역은 BSS(Block Started by Symbol) segment, Data segment로 나뉘는데

- BSS 세그먼트에는 0으로 초기화 되어 있거나 어떤 값으로도 초기화 되어 있지 않은 전역 변수가 할당된다. 
- Data 세그먼트는 0이 아닌 값으로 초기화 된 전역 변수가 할당된다. 

코드 영역에는 실행 가능한 코드들이 들어간다. 

C언어 코드로 예시를 살펴보면 다음과 같다. 

<img width="750" src="https://velog.velcdn.com/images/jxlhe46/post/0c95e7e0-f2b9-4fbe-a20d-8ae73dc1b929/image.png"/> 

<img width="750" src="https://velog.velcdn.com/images/jxlhe46/post/e7dc643a-dad7-4bf1-9d3b-53e1e3fb4de9/image.png"/> 

# 3.3.4 PCB 

PCB (Process Control Block)은 운영체제에서 프로세스와 관련된 모든 정보를 저장하고 있는 구조체를 말한다. 프로세스 제어 블록이라고도 하는데, 프로세스가 생성되면 운영체제는 해당 프로세스의 PCB를 생성한다. 

프로그램이 메모리에 올라가 실행되면 프로세스가 되고, 위에서 설명한 스택, 힙 등의 구조를 기반으로 프로세스 주소 값들에 메모리가 할당된다. 그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리된다. 이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리된다. 

## PCB의 구조 

PCB는 다음과 같은 정보로 이루어져 있다. 

- **프로세스 상태: New, Running, Waiting, Ready, Terminated**
- 프로세스 ID: 프로세스 자신의 ID, 자식 프로세스의 ID 
- 프로세스 권한: 컴퓨터 자원 또는 입출력 장치에 대한 권한 정보 
- **프로그램 카운터: 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터** 
- CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보 
- CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보 
- 계정 정보: 프로세스 실행 시 CPU 사용량, 실행한 유저의 계정 정보 
- 입출력 상태 정보: 프로세스에 할당된 입출력 장치들의 목록 

![](https://velog.velcdn.com/images/jxlhe46/post/e7952db1-2c4f-4b65-8319-222d9bebb848/image.png) 

## 컨텍스트 스위칭 

프로세스가 사용되고 있는 상태를 문맥이라고 하는데, 이 정보는 다 PCB에 저장되어 있다. 따라서 운영체제 입장에서 문맥, 컨텍스트는 결국 PCB를 의미한다고 볼 수 있다. 

한 프로세스에 할당된 시간이 끝나거나 인터럽트가 발생하면 이러한 PCB가 서로 교환된다. 이를 컨텍스트 스위칭 (context switching)이라고 한다. 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태를 복원하는 식으로 진행된다. 

컴퓨터의 많은 프로세스가 동시에 구동되는 것처럼 보이는 이유는 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 진행되기 때문이다. (싱글코어 기준) 

![](https://velog.velcdn.com/images/jxlhe46/post/43e2fae9-61fe-497b-8431-06ca79be34f8/image.png) 

위의 그림에서 프로세스 P0가 실행되다가 인터럽트나 시스템 콜이 발생하면 그 상태가 PCB0에 저장되고, 프로세스 P1이 실행된다. 즉, PCB1으로부터 P1의 상태가 복원된다. 그러다가 다시 인터럽트가 발생하면, 이번에는 P1의 상태가 PCB1에 저장되고 P0의 상태는 PCB0로부터 복원된다. 이게 바로 여러 프로세스 간의 문맥 교환 (컨텍스트 스위치)이다. 

컨텍스트 스위칭이 일어날 때 유휴 시간 (idle time)이 발생하는 걸 볼 수 있다. 이뿐만 아니라 컨텍스트 스위칭이 일어날 때 프로세스가 갖고 있는 메모리 주소가 그대로 유지되면 잘못된 주소 변환이 생기므로 캐시를 클리어 하는 과정이 필요하다. 이를 캐시미스라고 한다. 

### 스레드에서의 컨텍스트 스위칭 

참고로 스레드에서도 컨텍스트 스위칭이 일어나는데, 스레드는 스택 영역을 제외한 모든 메모리를 서로 공유하기 때문에 스레드 컨텍스트 스위칭은 프로세스보다 비용도 시간도 더 적게 든다. 
