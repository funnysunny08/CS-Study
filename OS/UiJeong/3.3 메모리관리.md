# [원본](https://velog.io/@juijeong8324/OS-3)

CPU는 메모리에 올라와 있는 프로그램의 명령어를 실행한다. 메모리 계층과 메모리 관리를 알아보자. 

## Memory hierarchy(메모리 계층) 
![](https://velog.velcdn.com/images/juijeong8324/post/6f5cf398-85a3-4976-9e56-b8b95f258282/image.png)

| 메모리 계층|위치|설명|특징|속도|메모리 용량|
|---|---|---|---|---|----|
|Register(레지스터)|CPU 내부|CPU안의 작은 메모리|휘발성|가장 빠름|가장 적음|
|Cache(캐시)|CPU 내부|L1, L2 캐시를 지칭|휘발성|빠름|적음|
|Main Memory(주기억장치)|CPU 외부|RAM(Random Access Memory), ROM(Read Only Meomory)을 가리킴|RAM은 휘발성, ROM은 비휘발성|보통|보통|
|Secondary Memory(보조기억장치)|CPU 직접 접근 불가|HDD, SSD를 말함|비휘발성|낮음|많음|

- RAM은 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 필요 할 때마다 CPU에 빠르게 전달하는 역할 
- 계층이 위로 올라갈수록 가격은 비싸짐, 용량은 작아짐, 속도는 빨라짐 (EX. 16GB RAM보다 16GB SSD가 더 쌈)

> **🤔 Loading은 메모리 계층 구조로 인해 발생하는 거라고?**
![](https://img.mk.co.kr/mkde/ic_loading_img.gif)
Loading은 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않음을 의미

<br>

### Cache(캐시)
- 데이터를 미리 복사해 놓은 **_임시 저장소_**
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
-> 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약 가능 

- **Caching**
: 데이터를 더 빠른 저장소에 저장하는 것 
: 같은 데이터를 미래에 다시 쓸 확률이 더 높기 때문에 접근 속도를 향상하기 위함 

- **Caching 계층**
: 속도 차이를 해결하기 위한 계층과 계층 사이에 있는 계층 
EX) _**메모리**_와 _**CPU 사이**_의 속도 차이가 너무 커 중간에 _**레지스터 계층**_을 두어 속도 차이 해결
EX) 캐시 메모리와 보조기억장치 사이에 있는 **_주기억장치_** == 보조기억장치의 Caching 계층 

<br>

#### 지역성의 원리 
- 캐시 계층을 두는 것 말고 **_캐시를 직접 설정할 때_**는 _**자주 사용하는 데이터**_를 기반으로 설정
🤔 자주 사용하는 데이터에 대한 근거가 되는 것 == **_지역성_** 

- **시간 지역성(temporal locality)**
: 최근 사용한 데이터에 다시 접근하려는 특성
EX) for 반복문으로 이루어진 코드 안의 변수 i → i에 계속 접근해서 +1을 연이어 해야 함 
```js
let arr = Array.from({length:10}, ()=> 0);
console.log(arr)
for(let i=0; i<10; i+=1){
	arr[i] = i;
}

console.log(arr)

/*
[
	0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
]
[
	0, 1, 2, 3, 4,
    5, 6, 7, 8, 9
]
*/
```

<br>

- **공간 지역성(spatial locality)**
: 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하려는 특성 
EX) 앞의 코드를 보면 공간을 나타내는 배열 arr의 각 요소들에 i가 할당되며 해당 배열에 연속적으로 접근 

<br>

### 캐시히트와 캐시미스 
![CSE564ComputerArchitectureSummer2017](https://velog.velcdn.com/images/juijeong8324/post/3ab93150-5605-4385-9f04-9e01199d2361/image.png)
- **캐시히트(cache hit)** : 캐시에서 원하는 데이터를 찾은 경우, 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기에 빠름 
- **캐시미스(cache miss)** : 해당 데이터가 캐시에 없을 때 주메모리에 가서 데이터를 찾아오는 것, 시스템 버스 기반으로 작동하기에 느림 

<br>

#### 캐시매핑
: 캐시가 hit되기 위해 매핑하는 방법 
: CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때를 기반으로 설명 
: 레지스터가 캐시 계층으로써 역할을 잘 하려면 이 매핑을 어떻게 하느냐가 중요

|이름|설명|특징|
|---|---|---|
|직접 매핑(directed mapping)|메모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20 ... 이런 식으로 매핑|처리가 빠르지만 충돌 발생이 잦음|
|연관 매핑(associative mapping)|순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑|충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느림|
|집합 연관 매핑(set associative mapping)|직접 매핑 + 연관 매핑, 메모리가 1~100이 있고 캐시가 1~10이 있다면 캐시 1~5에는 1~50의 데이터를 무작위로 저장|순서는 일치시키지만 집합을 둬서 저장, 블록화되어 있기 때문에 검색은 효율적|

<br>

#### 웹 브라우저와 캐시
- 소프트웨어적 대표 캐시 : **_쿠키(cookie), 로컬 스토리지(local storage), 세션 스토리지(session storage)_**
- _**사용자의 커스텀한 정보**_나 _**인증 모듈 관련 사항들**_을 웹브라우저에 저장
- 추후에 서버에 요청할 때_** 자신을 나타내는 아이덴티티나 중복 요청방지**_를 위해 쓰임 

|이름|설명|특징|
|---|---|---|
|쿠키(cookie)|만료기한이 있는 키-값 저장소|- `same site` 옵션을 `strict`로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송 <br> - 4KB까지 데이터를 저장할 수 있음 <br> - 만료기한을 정할 수 있음 <br> - 쿠키 설정 시 `document.cookie`로 쿠키를 볼 수 없게 `httponly` 옵션을 걸어야 함 <br> - 보통 서버에서 만료기한을 정함(클라이언트에서 만료기한을 정할 수도 있음) |
|로컬 스토리지(local storage)|만료기한이 없는 키-값 저장소|-10MB까지 저장할 수 있음 <br> - 웹브라우저를 닫아도 유지됨 <br> - 도메인 단위로 저장, 생성 <br> - HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없음 <br> - 클라이언트에서만 수정 가능|
|세션 스토리지(session storage)|만료기한이 없는 키-값 저장소|- 탭 단위로 세션 스토리지를 생성 <br> - 탭을 닫을 때 해당 데이터가 삭제 <br> - 5MB까지 저장 가능 <br> - HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없음 <br> - 클라이언트에서만 수정 가능|

<br>

#### 데이터베이스의 캐싱 계층 
![](https://velog.velcdn.com/images/juijeong8324/post/7ee9dd43-42a0-4721-8c79-5350fa536e6b/image.png)
데이터베이스 시스템에서는...
→ 메인 데이터베이스 위에 _**레디스(redis) 데이터 베이스 계층(캐싱 계층)**_을 둠 
→ 성능 향상!

<br>
<br>

## 메모리 관리 
- 운영체제의 대표적인 할 일 중 하나 
- 컴퓨터 내의 한정된 메모리를 극한으로 활용해야 함 

<br>

### 가상 메모리(virtual memory)
- 메모리 관리 기법의 하나
- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화 
→ 사용자들에게 매우 큰 메모리로 보이게 만드는 것 <br>

- _**가상 주소(logical address)**_ 
: 가상적으로 주어진 주소 
: 가상 주소는 _**메모리관리장치(MMU)**_에 의해 _**실제 주소(physical addrss)**_로 변환
: 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있게 됨 <br>

- _**실제 주소(physical address)**_ 
: 실제 메모리상에 있는 주소 

![](https://velog.velcdn.com/images/juijeong8324/post/89991ffd-3707-4371-bc0f-5439424ad62e/image.png)
- 가상 메모리는 _**'페이지 테이블'**_로 관리하고 속도 향상을 위해 TLB를 사용
- 페이지 테이블(page table) : 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있음

> _**🤔 TLB가 뭐야?**_
- 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시 
- 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층 

<br>

#### 스와핑(swapping)
![](https://velog.velcdn.com/images/juijeong8324/post/5916fcee-24e4-4693-94ea-0bd574d105b9/image.png)
- 페이지 폴트를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것 


<br>

#### 페이지 폴트(page fault)
- 가상 메모리 혹은 프로세스 주소 공간에는 존재하지만 실제 메모리(RAM)에는 현재 없는 데이터나 코드에 접근할 경우 발생


<br>

### 스레싱
### 메모리 할당
### 페이지 교체 알고리즘




## 참고자료 
면접을 위한 CS 전공지식노트
[[OS] 메모리 계층 구조(Memory Hierachy)](https://velog.io/@yu-jin-song/CS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0)
[Redis: What It Is, What It Does, and Why You Should Care](https://backendless.com/redis-what-it-is-what-it-does-and-why-you-should-care/)
