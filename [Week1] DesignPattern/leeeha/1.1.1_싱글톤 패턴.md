# 1.1.1 싱글톤 패턴 

싱글톤 (Singleton) 패턴은 하나의 클래스를 기반으로 **단 하나의 인스턴스만 생성**하여 프로그램 어디에서나 해당 인스턴스에 접근하여 사용할 수 있도록 하는 패턴이며, 보통 데이터베이스 연결 모듈에 많이 사용한다고 한다. 

## 싱글톤 패턴의 장점 

- 메모리 낭비를 방지할 수 있다. 
- 싱글톤으로 만들어진 클래스와 다른 클래스의 인스턴스 간의 데이터 공유가 쉽다. 
- 인스턴스가 절대적으로 하나만 존재하는 것을 보장하기 때문에 개발 시 실수를 줄일 수 있다. 
- 싱글톤 객체를 사용하지 않는 경우에는 인스턴스를 생성하지 않는다. 
- 싱글톤을 상속시킬 수 있다. 

## 싱글톤 패턴의 단점 

- 싱글톤의 역할이 커질수록 결합도가 높아져 객체지향 설계 원칙에 어긋날 수 있다. 
- 멀티 스레드 환경에서 컨트롤이 어렵다. 
- 객체의 소멸 시점을 컨트톨 하기 어려울 수 있다. 

실제로 싱글톤 패턴은 TDD (Test Driven Development)를 할 때 걸림돌이 된다. TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다. 하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다. 

### 의존성 주입 

싱글톤 패턴은 사용하기 쉽고 굉장히 실용적이지만 **모듈 간의 결합을 강화시킬 수 있다는 단점**이 있다. 이때 의존성 주입 (DI, Dependency Injection)을 통해 모듈 간의 결합을 조금 더 느슨하게 만들 수 있다. 참고로 의존성은 종속성이라고도 하며 A가 B에 의존성이 있다는 건 A는 B에 따라 달라진다는 걸 의미한다. 

![image](https://user-images.githubusercontent.com/68090939/223058948-a5b42202-377b-4db9-9d83-056a492c2a18.png)

위의 그림처럼 메인 모듈이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는, 중간에 **의존성 주입자 (Dependency Injector)** 가 이 부분을 가로채서 메인 모듈이 '간접'적으로 의존성을 주입하도록 만든다. 이를 통해 메인 모듈 (상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 된다. 이를 '디커플링'된다고 표현한다.

의존성 주입을 하면, **모듈들을 쉽게 교체**할 수 있는 구조가 되어 **테스트 하기 쉽고 마이그레이션 하기도 수월**해진다. 그리고 구현할 때 추상화 레이어를 먼저 넣고 이를 기반으로 구체적인 구현체를 넣기 때문에 **어플리케이션의 의존성 방향이 일관**되고, 어플리케이션을 쉽게 추론할 수 있으며, **모듈 간의 관계들이 좀더 명확**해진다는 장점이 있다. 

하지만, 모듈들이 분리됨에 따라 클래스 수가 늘어나서 복잡성이 증가하고 약간의 런타임 패널티가 생길 수도 있다. 

의존성 주입의 원칙은, **"상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다"** 는 것이다. 또한, 둘다 추상화에 의존해야 하며 이때 추상화는 세부사항에 의존하지 말아야 한다. 

## 싱글톤 패턴 사용법 

싱글톤 패턴에서는 클래스 자체에서만 생성자에 접근할 수 있도록 **생성자에 private 접근 제어자**를 지정해줘야 한다. 만약 생성자를 public으로 해두면 해당 클래스를 다른 부분에서 인스턴스화 시킬 수 있기 때문이다. 그리고 접근 제어자와 더불어 **인스턴스가 수정되지 않도록** 해야 한다. 만약 인스턴스 생성 이후 수정이 가능하다면 해당 인스턴스를 null로 초기화 시킬 수도 있기 때문이다. 

### 이른 초기화 (Eager Initialization) 

```java 
public class Singleton {
  private static Singleton instance = new Singleton(); // 인스턴스 생성 
  private Singleton() {} // 생성자를 private으로 
  public static Singleton getInstance() {
    return instance; 
  }
}
```

이른 초기화는 **클래스가 호출될 때 인스턴스를 생성**하는 방법이다. 다만 인스턴스를 사용하지 않을 때도 클래스만 호출하면 인스턴스가 생성되기 때문에 효율성이 떨어진다. 

### 늦은 초기화 (Lazy Initialization) 

```java 
public class Singleton {
  private static Singleton instance; 
  private Singleton() {}
  public static Singleton getInstance() {
    if(instance == null) {
      instance = new Singleton(); 
    }
    return instance; 
  }
}
```

늦은 초기화는 **인스턴스를 실제로 사용하는 시점에 생성하는 방법**이다. 인스턴스를 사용하지 않으면 생성하지 않기 때문에 이른 초기화 보다 효율성이 좋긴 하다. 그런데, 멀티 스레드 환경에서 여러 스레드가 동시에 싱글톤 인스턴스에 접근하려고 하는 Race Condition이 발생할 경우, 여러 스레드가 인스턴스가 생성되지 않았음을 확인하고 모두 생성한다면 **인스턴스가 중복되는 문제**가 생길 수 있다. 

### 멀티 스레드 환경에서의 늦은 초기화 

```java 
public class Singleton {
  private static Singleton instance; 
  private Singleton() {}
  public static Singleton getInstance() {
    if(instance == null){
      // synchronized 키워드를 사용하여 여러 인스턴스가 생성되는 것을 방지 
      synchronized (Singleton.class) {
        if(instance == null) instance = new Singleton();
      }
    }
    
    return instance; 
  }
}
```

첫번째 if문에서 인스턴스의 생성 여부를 검사하여 생성되어 있지 않다면, 두번째 if문에서 다시 한번 검사할 때 **synchronized로 동기화 시켜서 여러 스레드가 접근하지 못하게 하는 방법**이다. 다시 클래스가 호출될 때에는 이미 인스턴스가 생성되어 있기 때문에 synchronized 블록에 접근하지 않는다. 이런 식으로 멀티 스레드 환경에서 싱글톤 패턴을 구현하면 인스턴스가 중복 생성되는 문제를 해결할 수 있다. 

## 참고자료 

https://coding-factory.tistory.com/709

https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html

