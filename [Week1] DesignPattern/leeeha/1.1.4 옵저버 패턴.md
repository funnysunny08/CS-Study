# 1.1.4 옵저버 패턴 

옵저버 (Observer)는 관찰자, 감시자 라는 뜻을 갖고 있다. 따라서 옵저버 패턴은 **어떤 이벤트가 일어나는 걸 감시하는 패턴**을 의미한다. 안드로이드를 예로 들면, 이벤트가 발생한 순간은 다음과 같은 것들이 있다. 

>1. 사용자가 키보드를 눌렀을 때 
>2. 사용자가 어떤 버튼을 터치했을 때 
>3. 호출한 API 응답 데이터가 수신되었을 때 

이러한 이벤트들을 감시하여, **이벤트가 발생할 때마다 미리 정의해둔 어떤 동작을 즉각 수행하게 하는 디자인 패턴**을 옵저버 패턴이라고 한다. 

옵저버 패턴을 이용하면 별도의 함수를 호출하지 않아도 객체의 상태 변화를 즉각적으로 알 수 있기 때문에, 이벤트 처리를 자주 해야 하는 프로그램에서 효과적으로 활용할 수 있다. 

## 옵저버 패턴의 원리 이해하기  

이벤트가 발생하는 클래스 B가 있고, 이 B 클래스에서 발생하는 이벤트를 수신하고 싶어하는 클래스 A가 있다고 해보자. 

클래스 A에서 B의 이벤트를 수신하기 위해 클래스 B를 인스턴스화 한 뒤, 이벤트가 발생할 때마다 B가 A의 메소드를 호출하도록 시킨다면? 

클래스 B에서는 이벤트가 정상적으로 발생하고 있지만, A가 일방적으로 B를 인스턴스화 한 상황이기 때문에 B는 A에 접근할 방법이 없다. 이 문제를 해결하기 위해 A와 B 중간에 인터페이스를 끼워넣을 수 있다. 

그러면 B에서 이벤트가 발생할 때마다 A가 만들어둔 종을 울리도록 할 수 있다. A는 종이 울릴 때마다 이를 알아차리고 이벤트가 감지되었을 때 수행할 동작을 자연스럽게 하는 흐름이 나온다. 

이를 위해 A는 인터페이스를 상속하여 이벤트가 발생할 때마다 실행할 메소드를 구현해둔다. 그리고 B를 생성할 때 생성자의 인자에 인터페이스 구현체를 전달하여, A가 구현해둔 인터페이스의 메소드를 호출할 수 있게 한다. 

>이때, 이 인터페이스를 **Observer (옵저버)** 라고 부른다. 코틀린에서는 **Listener (리스너)** 라는 용어를 사용한다. 그리고 B가 A가 구현해둔 인터페이스의 메소드를 호출함으로써 이벤트를 전달하는 행위를 **Callback (콜백)** 이라고 한다. 

## 옵저버 패턴 구현하기 (Kotlin 기준)

- 1부터 100까지 하나씩 늘려가며 5의 배수를 만날 때마다 이벤트를 발생시키는 Counter 클래스 
- 객체의 상태 변화를 관찰하고 있다가 이벤트가 발생할 때마다 이를 수신하여 결과를 처리하는 EventPrinter 클래스 
- 이벤트가 발생하는 클래스와 이를 수신하는 클래스를 연결해주는 인터페이스 (옵저버, 리스너)


```kotlin 
// 리스너 인터페이스 정의 
interface EventListener {
    fun onEvent(count: Int) 
}
```

```kotlin 
// 5의 배수가 감지될 때마다 이벤트를 발생시키는 클래스 정의 
class Counter(var listener: EventListener){
    fun count(){
        for(i in 1..100){
            if(i % 5 == 0){
                listener.onEvent(i) 
            }
        }
    }
}
```

```kotlin 
// 이벤트를 수신하여 결과를 처리하는 클래스 정의 
class EventPrinter: EventListener {
    // 상속 받은 인터페이스의 메소드 구현 
    override fun onEvent(count: Int){
        print("${count} ")
    }

    fun start(){
        // 인터페이스 구현부가 생성자의 인자로 전달되고, 5의 배수가 감지되어 이벤트가 발생할 때마다 print("${count} ") 함수가 실행된다. 
        Counter(this).count() 
    }
}
```

```kotlin 
// 실행 
fun main(){
    EventPrinter().start() 
}
```

### 좀 더 코틀린스럽게 바꾸기 

위에서는 EventPrinter 클래스는 EventListener 인터페이스를 상속 받아 구현하고 있다. 하지만, 코틀린에서는 '익명 객체'를 통해 임시로 EventListener를 상속 받아 구현한 객체를 생성하여 생성자의 인자로 넘겨줄 수 있다. 

```kotlin 
class EventPrinter {
    fun start(){
        val counter = Counter(object: EventListener {
            override fun onEvent(count: Int){
                print("${count} ")
            }
        })
        counter.count() 
    }
}
```

옵저버 패턴은 다른 객체의 상태 변화를 감지함에 있어서 **객체끼리 느슨하게 결합**되는 형태이기 때문에, 의존성을 제거하고 시스템을 보다 유연하게 해주는 효과가 있다. 

## 참고자료 

[옵저버-패턴-개념-떠먹여드립니다](https://velog.io/@haero_kim/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90-%EB%96%A0%EB%A8%B9%EC%97%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)
